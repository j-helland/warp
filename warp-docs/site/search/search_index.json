{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"TODO","title":"Home"},{"location":"dev_guide/","text":"Developer Guide Design Goals Warning WARP is still in early development, which means that there is a limited set of functionality and, moreover, the design principles for the tool are not fully realized. The following exposition is more idealistic than what is reflected by the current functionality of the tool so as to reflect what the tool should become . WARP itself intends to be a tool, not a framework. In this sense, the goal of this page is not to give you a specific ideological approach to organizing your pipelines -- rather, the goal is to demonstrate WARP functionality so that you can make your own organizational decisions. That being said, there are still general practices that WARP intends to encourage through the following design philosophy: complicated / bug-prone pipeline behavior should require explicit code expressions that reflect this complexity. You can very much do the \"wrong thing\" in WARP, but the tool should encourage you to be transparent about it.","title":"Developer Guide"},{"location":"dev_guide/#developer-guide","text":"","title":"Developer Guide"},{"location":"dev_guide/#design-goals","text":"Warning WARP is still in early development, which means that there is a limited set of functionality and, moreover, the design principles for the tool are not fully realized. The following exposition is more idealistic than what is reflected by the current functionality of the tool so as to reflect what the tool should become . WARP itself intends to be a tool, not a framework. In this sense, the goal of this page is not to give you a specific ideological approach to organizing your pipelines -- rather, the goal is to demonstrate WARP functionality so that you can make your own organizational decisions. That being said, there are still general practices that WARP intends to encourage through the following design philosophy: complicated / bug-prone pipeline behavior should require explicit code expressions that reflect this complexity. You can very much do the \"wrong thing\" in WARP, but the tool should encourage you to be transparent about it.","title":"Design Goals"},{"location":"roadmap/","text":"Upcoming Features","title":"Roadmap"},{"location":"roadmap/#upcoming-features","text":"","title":"Upcoming Features"},{"location":"user_guide/","text":"User Guide WARP stands for Workspace Allowing Reproducible Pipelines. This page will serve as a reference for how to use WARP in practice. It contains a tutorial . Introductory Tutorial In this tutorial, we will create a minimal pipeline that will guide you through the functionality of WARP. The pipeline itself is fairly abstract, intending to reflect structural details one might encounter in a machine learning workflow rather than the implementation minutia. The basic idea of WARP is to consider your pipeline as a Directed Acyclic Graph (DAG) in which edges represent pieces of data and vertices represent functions that operate on those pieces of data. There are three core classes you need to understand in order to use WARP: Pipe : The core functional unit of WARP -- a chunk of code that takes in pieces of data and outputs (new) pieces of data. Pipes behave like relatively self-contained functions that explicitly declare what data they depend on and what data they produce, thereby implicitly defining a DAG. The user will wrap their pipeline functionality with these pipe classes. Graph : The data structure that formally connects pipes together into a DAG. The user will rarely interact directly with this object beyond instantiating it and passing it to Workspace . Workspace : An API for the user to interact with the graph that keeps track of metadata and data provenance. Using Pipe Abstract This section demonstrates the following concepts: Source pipes -- how to ingest external data artifacts. Pipe subclasses -- how to define data processing functionality. The @dependencies decorator -- how to declare which pieces of data the pipe ingests. The @produces decorator -- how to declare which pieces of data the pipe outputs for ingestion by other pipes. TODO In this section, we will create two pipes. The full pipeline used in this tutorial contains additional pipes, which you can find [TODO]. The first thing you must do is encapsulate your pipeline data processing code into a Pipe subclass. Important You can only declare one Pipe subclass per file. Example In this example, we create a Pipe subclass that will ingest a dataset and output a new preprocessed dataset. The next example creates a downstream pipe that relies on this one. TODO Advanced Tutorial","title":"User Guide"},{"location":"user_guide/#user-guide","text":"WARP stands for Workspace Allowing Reproducible Pipelines. This page will serve as a reference for how to use WARP in practice. It contains a tutorial .","title":"User Guide"},{"location":"user_guide/#introductory-tutorial","text":"In this tutorial, we will create a minimal pipeline that will guide you through the functionality of WARP. The pipeline itself is fairly abstract, intending to reflect structural details one might encounter in a machine learning workflow rather than the implementation minutia. The basic idea of WARP is to consider your pipeline as a Directed Acyclic Graph (DAG) in which edges represent pieces of data and vertices represent functions that operate on those pieces of data. There are three core classes you need to understand in order to use WARP: Pipe : The core functional unit of WARP -- a chunk of code that takes in pieces of data and outputs (new) pieces of data. Pipes behave like relatively self-contained functions that explicitly declare what data they depend on and what data they produce, thereby implicitly defining a DAG. The user will wrap their pipeline functionality with these pipe classes. Graph : The data structure that formally connects pipes together into a DAG. The user will rarely interact directly with this object beyond instantiating it and passing it to Workspace . Workspace : An API for the user to interact with the graph that keeps track of metadata and data provenance.","title":"Introductory Tutorial"},{"location":"user_guide/#using-pipe","text":"Abstract This section demonstrates the following concepts: Source pipes -- how to ingest external data artifacts. Pipe subclasses -- how to define data processing functionality. The @dependencies decorator -- how to declare which pieces of data the pipe ingests. The @produces decorator -- how to declare which pieces of data the pipe outputs for ingestion by other pipes. TODO In this section, we will create two pipes. The full pipeline used in this tutorial contains additional pipes, which you can find [TODO]. The first thing you must do is encapsulate your pipeline data processing code into a Pipe subclass. Important You can only declare one Pipe subclass per file. Example In this example, we create a Pipe subclass that will ingest a dataset and output a new preprocessed dataset. The next example creates a downstream pipe that relies on this one. TODO","title":"Using Pipe"},{"location":"user_guide/#advanced-tutorial","text":"","title":"Advanced Tutorial"},{"location":"data/data/","text":"Data Decorators that implicitly define the pipeline graph by ingesting upstream products that a Pipe subclass depends on as well as products that the pipe will produce for downstream pipes to ingest themselves. These must be used for WARP to properly construct a graph of your pipeline. @dependencies dependencies ( ** kwargs ) Link Product instances as dependencies of a Pipe subclass. This decorator should be decorate the run function therein. Examples: class B ( Pipe ): @dependencies ( product = A . product ) def run ( self ) -> None : # At runtime, `A.product` will be available to this pipe as a class-level attribute under the kwarg name. self . product Parameters: Name Type Description Default kwargs Dict[str, warp.pipes.attributes.Product] You must specify dependencies with str type keys and Product instance values. {} @produces produces ( ** kwproducts ) Declare the products of a pipe. Products fed to this decorator will be automatically pickled after the wrapped function finishes unless the save and load arguments of Product are specified. Because we want non-static products to be cached in a session-specific location, we unfortunately need to refer to a global variable that specifies this session warp.globals.product_dir() . Examples: class A ( Pipe ): product = warp . Product ( 'product' ) @produces ( product = product ) def run ( self ) -> None : ... Parameters: Name Type Description Default kwproducts Dict[str, warp.pipes.attributes.Product] Values must be Product instances and keys must match the name of the product. {} Decorator TODO","title":"warp.data"},{"location":"data/data/#data","text":"Decorators that implicitly define the pipeline graph by ingesting upstream products that a Pipe subclass depends on as well as products that the pipe will produce for downstream pipes to ingest themselves. These must be used for WARP to properly construct a graph of your pipeline.","title":"Data"},{"location":"data/data/#dependencies","text":"","title":"@dependencies"},{"location":"data/data/#warp.data.dependencies.dependencies","text":"Link Product instances as dependencies of a Pipe subclass. This decorator should be decorate the run function therein. Examples: class B ( Pipe ): @dependencies ( product = A . product ) def run ( self ) -> None : # At runtime, `A.product` will be available to this pipe as a class-level attribute under the kwarg name. self . product Parameters: Name Type Description Default kwargs Dict[str, warp.pipes.attributes.Product] You must specify dependencies with str type keys and Product instance values. {}","title":"dependencies()"},{"location":"data/data/#produces","text":"","title":"@produces"},{"location":"data/data/#warp.data.produces.produces","text":"Declare the products of a pipe. Products fed to this decorator will be automatically pickled after the wrapped function finishes unless the save and load arguments of Product are specified. Because we want non-static products to be cached in a session-specific location, we unfortunately need to refer to a global variable that specifies this session warp.globals.product_dir() . Examples: class A ( Pipe ): product = warp . Product ( 'product' ) @produces ( product = product ) def run ( self ) -> None : ... Parameters: Name Type Description Default kwproducts Dict[str, warp.pipes.attributes.Product] Values must be Product instances and keys must match the name of the product. {}","title":"produces()"},{"location":"data/data/#decorator","text":"TODO","title":"Decorator"},{"location":"graph/graph/","text":"Graph A thin wrapper around a multi-digraph which provides some syntax for adding Pipe subclasses. Nodes refer to Pipe subclasses. Edges represent Product instances. An instantiated Graph is required in order to create a Workspace . Special syntax is provided to reduce the verbosity of adding Pipe subclasses to the graph. Note that both of the following operators can be composed. The >> operator is a basic add operation. This operator that you should use for adding whenever possible. Note An error will raise if the Pipe subclass(es) producing the @dependencies of the Pipe subclass to be added do not already exist in the graph as nodes. The @ operator is an add operation with the additional semantics that any @dependencies that are not already @produces outputs of an existing node in the graph will be added as Source products. Note Source pipes will appear in the Graph under the naming convention __source__{pipe name}{i} , where {pipe name} is the automatically derived name of the Pipe subclass being added and {i} is a unique index for resolving cases in which multiple sources are specified. Warning This operator should be used with caution as it can silently create unexpected Graph topologies. Examples: Example In the following example, we take Pipe subclasses A , B , C , and D and add them to a Graph object. g = Graph () g @ A + B + C + D The last line is equivalent to g @ A g + B g + C g + D which is in turn equivalent to g . add ( A , make_dependencies_sources = True ) g . add ( B ) g . add ( C ) g . add ( D ) Note Since the topology of the Graph is defined implicitly by the @dependencies and @produces decorators within a Pipe subclass declaration, the syntax A >> B >> C >> D does not mean that the graph will be a linked list from A to B . In this sense, the topology of the Graph is not reflected by the >> operator. __init__ ( self ) special add ( self , pipe , * , make_dependencies_sources = False , override_existing_attrs = False , docstring = None ) Create a node in the graph for a Pipe subclass. Moreover, create edges between existing nodes whose Product instances are @dependencies of the new node. By default, an error will be raised if @dependencies exist that cannot be found in the graph. Using the make_dependencies_sources=True flag will cause such @dependencies to be added as the outputs of a Source node. Parameters: Name Type Description Default pipe module Must be a subclass of the Pipe class. required make_dependencies_sources bool Instead of raising an error when the @dependencies of pipe are not found, create a Source node whose outputs are the missing @dependencies . False override_existing_attrs bool Flag to allow overriding of existing class-level attributes of pipe . This flag is used internally to allow reloading of the graph, since declaring @dependencies will create corresponding class-level attributes, the overriding of which is disallowed by default. Important This flag is for internal use only -- the user should never need this. False docstring Optional[str] An optional descriptor of the pipe 's functionality. None Returns: Type Description object self get_parents_from_products ( self , products ) return a list of pipes that have products matching products argument get_pipe_instance ( self , pipe_name ) get_pipe_module ( self , pipe ) Search module for class declarations subclassing Pipe . There should only be one of these per file. get_pipe_name_from_abbreviation ( self , name ) Fuzzy matching of a string to the existing pipe names in the graph. is_source_pipe ( pipe_name ) staticmethod paths ( self , source , dest ) Identify all paths from source to destination","title":"Graph"},{"location":"graph/graph/#graph","text":"A thin wrapper around a multi-digraph which provides some syntax for adding Pipe subclasses. Nodes refer to Pipe subclasses. Edges represent Product instances. An instantiated Graph is required in order to create a Workspace . Special syntax is provided to reduce the verbosity of adding Pipe subclasses to the graph. Note that both of the following operators can be composed. The >> operator is a basic add operation. This operator that you should use for adding whenever possible. Note An error will raise if the Pipe subclass(es) producing the @dependencies of the Pipe subclass to be added do not already exist in the graph as nodes. The @ operator is an add operation with the additional semantics that any @dependencies that are not already @produces outputs of an existing node in the graph will be added as Source products. Note Source pipes will appear in the Graph under the naming convention __source__{pipe name}{i} , where {pipe name} is the automatically derived name of the Pipe subclass being added and {i} is a unique index for resolving cases in which multiple sources are specified. Warning This operator should be used with caution as it can silently create unexpected Graph topologies. Examples: Example In the following example, we take Pipe subclasses A , B , C , and D and add them to a Graph object. g = Graph () g @ A + B + C + D The last line is equivalent to g @ A g + B g + C g + D which is in turn equivalent to g . add ( A , make_dependencies_sources = True ) g . add ( B ) g . add ( C ) g . add ( D ) Note Since the topology of the Graph is defined implicitly by the @dependencies and @produces decorators within a Pipe subclass declaration, the syntax A >> B >> C >> D does not mean that the graph will be a linked list from A to B . In this sense, the topology of the Graph is not reflected by the >> operator.","title":"Graph"},{"location":"graph/graph/#warp.graph.graph.Graph.__init__","text":"","title":"__init__()"},{"location":"graph/graph/#warp.graph.graph.Graph.add","text":"Create a node in the graph for a Pipe subclass. Moreover, create edges between existing nodes whose Product instances are @dependencies of the new node. By default, an error will be raised if @dependencies exist that cannot be found in the graph. Using the make_dependencies_sources=True flag will cause such @dependencies to be added as the outputs of a Source node. Parameters: Name Type Description Default pipe module Must be a subclass of the Pipe class. required make_dependencies_sources bool Instead of raising an error when the @dependencies of pipe are not found, create a Source node whose outputs are the missing @dependencies . False override_existing_attrs bool Flag to allow overriding of existing class-level attributes of pipe . This flag is used internally to allow reloading of the graph, since declaring @dependencies will create corresponding class-level attributes, the overriding of which is disallowed by default. Important This flag is for internal use only -- the user should never need this. False docstring Optional[str] An optional descriptor of the pipe 's functionality. None Returns: Type Description object self","title":"add()"},{"location":"graph/graph/#warp.graph.graph.Graph.get_parents_from_products","text":"return a list of pipes that have products matching products argument","title":"get_parents_from_products()"},{"location":"graph/graph/#warp.graph.graph.Graph.get_pipe_instance","text":"","title":"get_pipe_instance()"},{"location":"graph/graph/#warp.graph.graph.Graph.get_pipe_module","text":"Search module for class declarations subclassing Pipe . There should only be one of these per file.","title":"get_pipe_module()"},{"location":"graph/graph/#warp.graph.graph.Graph.get_pipe_name_from_abbreviation","text":"Fuzzy matching of a string to the existing pipe names in the graph.","title":"get_pipe_name_from_abbreviation()"},{"location":"graph/graph/#warp.graph.graph.Graph.is_source_pipe","text":"","title":"is_source_pipe()"},{"location":"graph/graph/#warp.graph.graph.Graph.paths","text":"Identify all paths from source to destination","title":"paths()"},{"location":"pipes/attributes/","text":"Attributes Parameter A wrapper for pipeline parameters that can be loaded from and saved to YAML files. This class is meant to be used to create class-level attributes of your Pipe subclass (see example below). When used in this way, Parameter objects can be treated syntactically like the value that they contain. Examples: Example class A ( Pipe ): p = Parameter ( 'pname' , default = 0 ) def run ( self ) -> None : # `p` can be used like a regular class attribute. print ( self . p ) self . p += 1 print ( self . p ) __init__ ( self , name , ** kwargs ) special Parameters: Name Type Description Default name str Identifier for the parameter. If loading the value from a YAML config file, this needs to match the corresponding field name. required default ( Optional[Any] ) The default value that will be used for the parameter if no config file is specified. If not specified, the value of the parameter will be name unless overridden by a config file. The type of this value must be serializable to a YAML file -- it cannot be a function or a class. An error will be raised if the type is not allowed. required Product A wrapper for the inputs/outputs of Pipe subclasses. The saving/loading behavior is altered by passing various flags to __init__ . By default, products passed into @produces will be pickled to the WARP cache location associated with the active session at runtime. Similarly, products passed into @dependencies will be unpickled Custom saving/loading functions can be attached to a Product if pickling is not desired. Note The topology of the Graph is implicitly defined by passing Product instances to the @dependencies and @produces decorators in the Pipe declaration. Tip Product provides the custom syntax <<< , which is shorthand for assigning a value to the Product.value attribute. Example p = Product ( 'p' ) p << 0 p . value = 0 # equivalent Info Product contains the following class-level attributes that change the behavior of Workspace.build . __source__ : The name of the pipe that produced this product. __static__ : Specifies whether or not to cache the product statically. __external__ : Specifies whether or not to cache the product externally. __save__ : Specifies whether to cache the product or to leave it in working memory. path : str property readonly The correctly resolved path to the Product based on the state of the __external__ and __static__ attributes. Warning The correct WARP cache location for the current session must still be resolved, which can be done via path.format(warp.globals.product_dir()) . __init__ ( self , path , * , static = False , external = False , save = None , load = None ) special Parameters: Name Type Description Default path str The relative path to save the product value to after the run() function of a Pipe subclass finishes. By default, this path will be appended to the path corresponding to the current WARP session directory in the WARP cache. Both static and external modify this behavior. If static=True , path will instead be appended to the static_products/ subdirectory of the WARP cache. If external=True , then the path will remain unaltered regardless of the static flag. required static bool Flag to mark this product as static, meaning that this product will be visible to other sessions. Unless external=True is specified, this will cause path to be appended to the static_products/ subdirectory of the WARP cache. False external bool Flag to mark this product as external, meaning that its path will left unmodified. Info This flag is used by the implementation of Source to allow the ingestion of external data artifacts into the pipeline. False save Union[bool, function] None : Cache the Product value by calling pickle . FunctionType : A user-defined callable implementing custom saving behavior. The function must have the signature (path: str, value: Any) -> None . The path argument to this function will always be the fully resolved file location. Passing a custom callable to save requires also passing a custom callable to load . Example The default save function is implemented in WARP as def save ( path : str , value : Any ) -> None : warp . utils . pickle ( path , value ) Warning This callable must create a file specified by path , otherwise WARP will detect this pipe as unbuilt and trigger rebuilds. False : Do not cache the product -- rather, leave it in working memory. Warning During backfill calls, products that are not cached in this manner will trigger rebuilds of the upstream pipes that produced them if said upstream pipes are direct ancestors of the target pipe. None load Optional[function] None : Call unpickle on the specified path . FunctionType : A user-defined callable implementing custom loading behavior. The callable must have the signature (path: str) -> Any . The path argument to this function will always be the fully resolved file location. Passing a custom callable to load requires also passing a custom callable to save . Example The default load function is implemented in WARP as def load ( path : str ) -> Any : return warp . utils . unpickle ( path ) None ParameterFile A wrapper for declaring a config file to load Parameter values from. This config file should contain at least one field that corresponds to a parameter of the pipe in which this config is used. This should be used as a class-level attribute of your Pipe subclass. Examples: class A ( Pipe ): # Must have a field `p_field` e.g. `p_field: 0` config = ParameterFile ( '../configs/A.yml' ) p = Parameter ( 'p_field' ) def run ( self ) -> None : # The value from the config file. # In this case, the output will be `p value 0`. print ( 'p value: ' , p ) __init__ ( self , path , multi_use = False ) special Parameters: Name Type Description Default path str File path to a valid YAML file with fields matching Parameter names. required multi_use bool Flag to allow a config file to be used by more than just this pipe. In such cases, each pipe declaring this config file must use this flag. False AbstractPipeObject TODO","title":"attributes"},{"location":"pipes/attributes/#attributes","text":"","title":"Attributes"},{"location":"pipes/attributes/#parameter","text":"A wrapper for pipeline parameters that can be loaded from and saved to YAML files. This class is meant to be used to create class-level attributes of your Pipe subclass (see example below). When used in this way, Parameter objects can be treated syntactically like the value that they contain. Examples: Example class A ( Pipe ): p = Parameter ( 'pname' , default = 0 ) def run ( self ) -> None : # `p` can be used like a regular class attribute. print ( self . p ) self . p += 1 print ( self . p )","title":"Parameter"},{"location":"pipes/attributes/#warp.pipes.attributes.Parameter.__init__","text":"Parameters: Name Type Description Default name str Identifier for the parameter. If loading the value from a YAML config file, this needs to match the corresponding field name. required default ( Optional[Any] ) The default value that will be used for the parameter if no config file is specified. If not specified, the value of the parameter will be name unless overridden by a config file. The type of this value must be serializable to a YAML file -- it cannot be a function or a class. An error will be raised if the type is not allowed. required","title":"__init__()"},{"location":"pipes/attributes/#product","text":"A wrapper for the inputs/outputs of Pipe subclasses. The saving/loading behavior is altered by passing various flags to __init__ . By default, products passed into @produces will be pickled to the WARP cache location associated with the active session at runtime. Similarly, products passed into @dependencies will be unpickled Custom saving/loading functions can be attached to a Product if pickling is not desired. Note The topology of the Graph is implicitly defined by passing Product instances to the @dependencies and @produces decorators in the Pipe declaration. Tip Product provides the custom syntax <<< , which is shorthand for assigning a value to the Product.value attribute. Example p = Product ( 'p' ) p << 0 p . value = 0 # equivalent Info Product contains the following class-level attributes that change the behavior of Workspace.build . __source__ : The name of the pipe that produced this product. __static__ : Specifies whether or not to cache the product statically. __external__ : Specifies whether or not to cache the product externally. __save__ : Specifies whether to cache the product or to leave it in working memory.","title":"Product"},{"location":"pipes/attributes/#warp.pipes.attributes.Product.path","text":"The correctly resolved path to the Product based on the state of the __external__ and __static__ attributes. Warning The correct WARP cache location for the current session must still be resolved, which can be done via path.format(warp.globals.product_dir()) .","title":"path"},{"location":"pipes/attributes/#warp.pipes.attributes.Product.__init__","text":"Parameters: Name Type Description Default path str The relative path to save the product value to after the run() function of a Pipe subclass finishes. By default, this path will be appended to the path corresponding to the current WARP session directory in the WARP cache. Both static and external modify this behavior. If static=True , path will instead be appended to the static_products/ subdirectory of the WARP cache. If external=True , then the path will remain unaltered regardless of the static flag. required static bool Flag to mark this product as static, meaning that this product will be visible to other sessions. Unless external=True is specified, this will cause path to be appended to the static_products/ subdirectory of the WARP cache. False external bool Flag to mark this product as external, meaning that its path will left unmodified. Info This flag is used by the implementation of Source to allow the ingestion of external data artifacts into the pipeline. False save Union[bool, function] None : Cache the Product value by calling pickle . FunctionType : A user-defined callable implementing custom saving behavior. The function must have the signature (path: str, value: Any) -> None . The path argument to this function will always be the fully resolved file location. Passing a custom callable to save requires also passing a custom callable to load . Example The default save function is implemented in WARP as def save ( path : str , value : Any ) -> None : warp . utils . pickle ( path , value ) Warning This callable must create a file specified by path , otherwise WARP will detect this pipe as unbuilt and trigger rebuilds. False : Do not cache the product -- rather, leave it in working memory. Warning During backfill calls, products that are not cached in this manner will trigger rebuilds of the upstream pipes that produced them if said upstream pipes are direct ancestors of the target pipe. None load Optional[function] None : Call unpickle on the specified path . FunctionType : A user-defined callable implementing custom loading behavior. The callable must have the signature (path: str) -> Any . The path argument to this function will always be the fully resolved file location. Passing a custom callable to load requires also passing a custom callable to save . Example The default load function is implemented in WARP as def load ( path : str ) -> Any : return warp . utils . unpickle ( path ) None","title":"__init__()"},{"location":"pipes/attributes/#parameterfile","text":"A wrapper for declaring a config file to load Parameter values from. This config file should contain at least one field that corresponds to a parameter of the pipe in which this config is used. This should be used as a class-level attribute of your Pipe subclass. Examples: class A ( Pipe ): # Must have a field `p_field` e.g. `p_field: 0` config = ParameterFile ( '../configs/A.yml' ) p = Parameter ( 'p_field' ) def run ( self ) -> None : # The value from the config file. # In this case, the output will be `p value 0`. print ( 'p value: ' , p )","title":"ParameterFile"},{"location":"pipes/attributes/#warp.pipes.attributes.ParameterFile.__init__","text":"Parameters: Name Type Description Default path str File path to a valid YAML file with fields matching Parameter names. required multi_use bool Flag to allow a config file to be used by more than just this pipe. In such cases, each pipe declaring this config file must use this flag. False","title":"__init__()"},{"location":"pipes/attributes/#abstractpipeobject","text":"TODO","title":"AbstractPipeObject"},{"location":"pipes/pipes/","text":"Pipes The kinds of pipes that WARP will recognize. Pipe is the main class to care about, while Source is a helper for adding source products to the graph that can be referenced as class-level attributes similarly to those of a Pipe subclass. Pipe Pipe must be subclassed by user-defined pipes in order to be recognized by WARP. Subclasses can have any name but are restricted to one declaration per file (with the exception of Source ). Info The @dependencies and @produces decorators mutate the __attrs__ class-level attribute of Pipe which is then used by Workspace , which is essentially a roundabout way of making __attrs__ a global variable. __attrs__ itself is a dict mapping Pipe subclass names to Product instances that were passed to the @dependencies and @produces decorators. More specifically, Workspace accesses this quasi-global variable __attrs__ using class-level methods __dependencies__ and __products__ of Pipe . Examples: Example The following is a minimal example of a Pipe declaration, which is placed in its own file. # A.py from warp import Pipe class A ( Pipe ): def run ( self ) -> None : print ( 'A.run()' ) __call__ ( self ) special Calls the run function. clear_all ( self , name ) Call both clear_products and clear_dependencies . In addition, find all attributes of the pipe specified by the name argument that are Product instances and set their value to None . Parameters: Name Type Description Default name str The full name of the Pipe subclass to clear. required clear_dependencies ( name ) classmethod Iterate over all Product instances passed to the @dependencies decorator and call delattr on them. Parameters: Name Type Description Default name str The full name of the Pipe subclass to clear. required clear_products ( name ) classmethod Iterate over all Product instances passed to the @produces decorator and set their value attributes to None . Parameters: Name Type Description Default name str The full name of the Pipe subclass to clear. required load_products () classmethod For the current Pipe subclass, create class-level attributes containing the value of the Product instances passed to @dependencies . This is what allows the user to access the outputs of upstream pipes as if they were attributes of the current Pipe context. Note This function is called in Workspace.build so that the requested @dependencies are available at runtime. Note The default behavior of this function is to load cached Product values since they are cleared from memory unless otherwise specified. This happens by calling the Product.load method. This behavior occurs if the Product.__save__ attribute is True . If save=False was passed to a Product constructor, then Product.__save__ = False and the value of the Product in memory is used. run ( self ) @abstractmethod This function must be declared by Pipe subclasses. Called by the __call__ function. save_products ( self ) For the current Pipe subclass, cache the values of each Product that was passed to the @produces decorator. Note The default behavior is to call the Product.save method and then set product.value = None . However, if Product.__save__ = False , then save_products does nothing. Source An class for conveniently declaring source Product instances that can be referenced by other Pipe declarations. Instances of Source contain an attribute Main which is a Pipe subclass, allowing Source instances to masquerade as python modules. Examples: Example This example shows how Source can be used to easily declare a source Product . Although you cannot declare multiple Pipe subclasses in the same file, you can declare Source instances in the same file as your pipe declaration. # A.py from warp import Source , Pipe , dependencies source = Source ()( p0 = 'path/to/product' ) class A ( Pipe ): @dependencies ( p0 = source . Main . p0 ) def run ( self ) -> None : print ( self . p0 ) __call__ ( self , * products , ** kwproducts ) special Dynamically create a Pipe subclass declaration with name Main and add it as an attribute of this instance. Arguments will be wrapped Parameters: Name Type Description Default products str Unnamed source products. These will become attributes of Source.Main under the naming convention product[INDEX] , where [INDEX] is a unique integer. Example s = Source()('path/to/file') will create s.Main.product0 . () kwproducts str Named source products. These will become attributes of Source.Main under the name specified by the keyword. Example s = Source()(user_product='path/to/file') will create s.Main.user_product . {} __init__ ( self , name = None ) special Source pipes will appear in the graph with the naming convention __source__{name} .","title":"pipes"},{"location":"pipes/pipes/#pipes","text":"The kinds of pipes that WARP will recognize. Pipe is the main class to care about, while Source is a helper for adding source products to the graph that can be referenced as class-level attributes similarly to those of a Pipe subclass.","title":"Pipes"},{"location":"pipes/pipes/#pipe","text":"Pipe must be subclassed by user-defined pipes in order to be recognized by WARP. Subclasses can have any name but are restricted to one declaration per file (with the exception of Source ). Info The @dependencies and @produces decorators mutate the __attrs__ class-level attribute of Pipe which is then used by Workspace , which is essentially a roundabout way of making __attrs__ a global variable. __attrs__ itself is a dict mapping Pipe subclass names to Product instances that were passed to the @dependencies and @produces decorators. More specifically, Workspace accesses this quasi-global variable __attrs__ using class-level methods __dependencies__ and __products__ of Pipe . Examples: Example The following is a minimal example of a Pipe declaration, which is placed in its own file. # A.py from warp import Pipe class A ( Pipe ): def run ( self ) -> None : print ( 'A.run()' )","title":"Pipe"},{"location":"pipes/pipes/#warp.pipes.pipes.Pipe.__call__","text":"Calls the run function.","title":"__call__()"},{"location":"pipes/pipes/#warp.pipes.pipes.Pipe.clear_all","text":"Call both clear_products and clear_dependencies . In addition, find all attributes of the pipe specified by the name argument that are Product instances and set their value to None . Parameters: Name Type Description Default name str The full name of the Pipe subclass to clear. required","title":"clear_all()"},{"location":"pipes/pipes/#warp.pipes.pipes.Pipe.clear_dependencies","text":"Iterate over all Product instances passed to the @dependencies decorator and call delattr on them. Parameters: Name Type Description Default name str The full name of the Pipe subclass to clear. required","title":"clear_dependencies()"},{"location":"pipes/pipes/#warp.pipes.pipes.Pipe.clear_products","text":"Iterate over all Product instances passed to the @produces decorator and set their value attributes to None . Parameters: Name Type Description Default name str The full name of the Pipe subclass to clear. required","title":"clear_products()"},{"location":"pipes/pipes/#warp.pipes.pipes.Pipe.load_products","text":"For the current Pipe subclass, create class-level attributes containing the value of the Product instances passed to @dependencies . This is what allows the user to access the outputs of upstream pipes as if they were attributes of the current Pipe context. Note This function is called in Workspace.build so that the requested @dependencies are available at runtime. Note The default behavior of this function is to load cached Product values since they are cleared from memory unless otherwise specified. This happens by calling the Product.load method. This behavior occurs if the Product.__save__ attribute is True . If save=False was passed to a Product constructor, then Product.__save__ = False and the value of the Product in memory is used.","title":"load_products()"},{"location":"pipes/pipes/#warp.pipes.pipes.Pipe.run","text":"@abstractmethod This function must be declared by Pipe subclasses. Called by the __call__ function.","title":"run()"},{"location":"pipes/pipes/#warp.pipes.pipes.Pipe.save_products","text":"For the current Pipe subclass, cache the values of each Product that was passed to the @produces decorator. Note The default behavior is to call the Product.save method and then set product.value = None . However, if Product.__save__ = False , then save_products does nothing.","title":"save_products()"},{"location":"pipes/pipes/#source","text":"An class for conveniently declaring source Product instances that can be referenced by other Pipe declarations. Instances of Source contain an attribute Main which is a Pipe subclass, allowing Source instances to masquerade as python modules. Examples: Example This example shows how Source can be used to easily declare a source Product . Although you cannot declare multiple Pipe subclasses in the same file, you can declare Source instances in the same file as your pipe declaration. # A.py from warp import Source , Pipe , dependencies source = Source ()( p0 = 'path/to/product' ) class A ( Pipe ): @dependencies ( p0 = source . Main . p0 ) def run ( self ) -> None : print ( self . p0 )","title":"Source"},{"location":"pipes/pipes/#warp.pipes.pipes.Source.__call__","text":"Dynamically create a Pipe subclass declaration with name Main and add it as an attribute of this instance. Arguments will be wrapped Parameters: Name Type Description Default products str Unnamed source products. These will become attributes of Source.Main under the naming convention product[INDEX] , where [INDEX] is a unique integer. Example s = Source()('path/to/file') will create s.Main.product0 . () kwproducts str Named source products. These will become attributes of Source.Main under the name specified by the keyword. Example s = Source()(user_product='path/to/file') will create s.Main.user_product . {}","title":"__call__()"},{"location":"pipes/pipes/#warp.pipes.pipes.Source.__init__","text":"Source pipes will appear in the graph with the naming convention __source__{name} .","title":"__init__()"},{"location":"utils/utils/","text":"Utils GlobalImport Convenient context manager for lazy importing of modules within a Pipe declaration. Since the lazily loaded modules are added to globals() , you can reference them anywhere in your pipeline runtime so long as the reference occurs after the context manager. Examples: # After the next two lines, `os` will be available for reference globally. with GlobalImport ( globals ()): import os __init__ ( self , gbls ) special Parameters: Name Type Description Default gbls dict You must pass globals() upon use. required function_call_stack () Returns the function call stack context. source: https://stackoverflow.com/a/2654130 hash_path ( path ) Creates a UTF-8 SHA1 hash of an input string. Parameters: Name Type Description Default path str The string value to hash. required Returns: Type Description str UTF-8 SHA1 hash of path . load_config_file ( path ) Load a YAML file into a dict. Extensions accepted are {.yml, .yaml} . Parameters: Name Type Description Default path str The relative path to the YAML file to load. required Returns: Type Description Dict[str, Any] A dict version of the YAML file. pickle ( path , value ) Function that pickles an object to the location specified by path . Parameters: Name Type Description Default path str The file path for the pickle file that will be created. required value Any The object to pickle. required recursive_update ( default , custom ) Recursively update nested dict default with the values of nested dict custom . Values present in custom but not present in default will be added to default . NOTE: this function operates inplace in default . Parameters: Name Type Description Default default Dict[str, Any] The dict whose values will be updated by the matching values of custom . required custom Dict[str, Any] The dict whose values will update the matching values of default . required Returns: Type Description Dict[str, Any] Updated version of default containing the values of custom. unpickle ( path ) Function that loads a pickle file generated by pickle(path) . Parameters: Name Type Description Default path str File path to a valid pickle file. required Returns: Type Description Any The unpickled object.","title":"warp.utils"},{"location":"utils/utils/#utils","text":"","title":"Utils"},{"location":"utils/utils/#globalimport","text":"Convenient context manager for lazy importing of modules within a Pipe declaration. Since the lazily loaded modules are added to globals() , you can reference them anywhere in your pipeline runtime so long as the reference occurs after the context manager. Examples: # After the next two lines, `os` will be available for reference globally. with GlobalImport ( globals ()): import os","title":"GlobalImport"},{"location":"utils/utils/#warp.utils.global_import.GlobalImport.__init__","text":"Parameters: Name Type Description Default gbls dict You must pass globals() upon use. required","title":"__init__()"},{"location":"utils/utils/#warp.utils.utils.function_call_stack","text":"Returns the function call stack context. source: https://stackoverflow.com/a/2654130","title":"function_call_stack()"},{"location":"utils/utils/#warp.utils.utils.hash_path","text":"Creates a UTF-8 SHA1 hash of an input string. Parameters: Name Type Description Default path str The string value to hash. required Returns: Type Description str UTF-8 SHA1 hash of path .","title":"hash_path()"},{"location":"utils/utils/#warp.utils.utils.load_config_file","text":"Load a YAML file into a dict. Extensions accepted are {.yml, .yaml} . Parameters: Name Type Description Default path str The relative path to the YAML file to load. required Returns: Type Description Dict[str, Any] A dict version of the YAML file.","title":"load_config_file()"},{"location":"utils/utils/#warp.utils.utils.pickle","text":"Function that pickles an object to the location specified by path . Parameters: Name Type Description Default path str The file path for the pickle file that will be created. required value Any The object to pickle. required","title":"pickle()"},{"location":"utils/utils/#warp.utils.utils.recursive_update","text":"Recursively update nested dict default with the values of nested dict custom . Values present in custom but not present in default will be added to default . NOTE: this function operates inplace in default . Parameters: Name Type Description Default default Dict[str, Any] The dict whose values will be updated by the matching values of custom . required custom Dict[str, Any] The dict whose values will update the matching values of default . required Returns: Type Description Dict[str, Any] Updated version of default containing the values of custom.","title":"recursive_update()"},{"location":"utils/utils/#warp.utils.utils.unpickle","text":"Function that loads a pickle file generated by pickle(path) . Parameters: Name Type Description Default path str File path to a valid pickle file. required Returns: Type Description Any The unpickled object.","title":"unpickle()"},{"location":"visualization/visualization/","text":"Visualization GUI GraphViz matplotlib_show ( graph , * , path = None , verbose = False ) Visualize the pipe graph using graphviz. :param path : Optional path to save image of workspace graph. :param verbose : If True, display the full node/edge labels.","title":"warp.visualization"},{"location":"visualization/visualization/#visualization","text":"","title":"Visualization"},{"location":"visualization/visualization/#gui","text":"","title":"GUI"},{"location":"visualization/visualization/#graphviz","text":"","title":"GraphViz"},{"location":"visualization/visualization/#warp.visualization.graphviz.matplotlib_show","text":"Visualize the pipe graph using graphviz. :param path : Optional path to save image of workspace graph. :param verbose : If True, display the full node/edge labels.","title":"matplotlib_show()"},{"location":"workspace/home/","text":"Home Manager for the WARP cache directory. Useful for creating new sessions and for getting file/dir paths relative to the session. Examples: Get the path to the cache directory associated with a session_id. session_id = 'DEV' home = Home ( session_id = session_id ) home () session_dir : str property readonly Get the unique subdirectory associated with the current run. Create the session directory if not yet initialized. __call__ ( self , relpath ) special Return the os.path.join of relpath with the WARP cache directory of the current session. __init__ ( self , path , session_id = None ) special Parameters: Name Type Description Default path str (Deprecated) Path to the WARP cache directory. required session_id Optional[str] The name of the session to create or load. None is_valid_session_id ( self , session_id ) Returns True if session_id has been used. Parameters: Name Type Description Default session_id str The name of the session. required","title":"Home"},{"location":"workspace/home/#home","text":"Manager for the WARP cache directory. Useful for creating new sessions and for getting file/dir paths relative to the session. Examples: Get the path to the cache directory associated with a session_id. session_id = 'DEV' home = Home ( session_id = session_id ) home ()","title":"Home"},{"location":"workspace/home/#warp.workspace.home.Home.session_dir","text":"Get the unique subdirectory associated with the current run. Create the session directory if not yet initialized.","title":"session_dir"},{"location":"workspace/home/#warp.workspace.home.Home.__call__","text":"Return the os.path.join of relpath with the WARP cache directory of the current session.","title":"__call__()"},{"location":"workspace/home/#warp.workspace.home.Home.__init__","text":"Parameters: Name Type Description Default path str (Deprecated) Path to the WARP cache directory. required session_id Optional[str] The name of the session to create or load. None","title":"__init__()"},{"location":"workspace/home/#warp.workspace.home.Home.is_valid_session_id","text":"Returns True if session_id has been used. Parameters: Name Type Description Default session_id str The name of the session. required","title":"is_valid_session_id()"},{"location":"workspace/workspace/","text":"Workspace The Workspace object is the main interface through which the user can interact with their pipeline -- it serves as a manager for the other core classes that WARP provides, namely the Graph . It provides a set of tools for generating desired outputs, inspecting historical outputs, and for visualizing the pipeline itself. Notably, Workspace is the object that enables pipeline reproducibility by keeping track of data provenance, parameter values used at runtime by each pipe, as well as some other metadata. It is also worth noting that Workspace can be integrated easily into other scripts that extend functionality e.g. a script that launches multiple sessions to be run in parallel. Creating a Workspace instance will typically be the last step in initializing your WARP pipeline. It requires an instantiated Graph object passed to __init__ . Once the Workspace instance has been created, the next most common step will be to call build or backfill to generate pipeline output. configs : Dict [ str , Any ] property readonly Search for declared config files and load them. Results are cached via @functools.lru_cache(maxsize=1) . methods : List [ str ] property readonly List the available methods for the user. pipes property readonly List the pipes present in the pipeline graph. session_timestamps : List [ float ] property readonly List the timestamp of each existing session. sessions : List [ str ] property readonly List the available sessions. __init__ ( self , * , graph = None , session_id = None , link_static_products = False ) special Parameters: Name Type Description Default graph Optional[str] Constructed pipeline graph. None session_id Optional[str] The unique id for the session to launch. If the id does not already exist, this creates a new session with that id. None link_static_products bool Link static products produced by other sessions to this session and resolve backfill operations accordingly. False backfill ( self , warp_pipe_name , * , configs = None , build_target_pipe = True , rebuild_all = False , rebuild_static_products = False ) Call build on all out-of-sync upstream pipes to warp_pipe_name , including warp_pipe_name itself as the terminal build. Note If there are no out-of-sync upstream pipes, backfill reduces to simply calling build on warp_pipe_name . Parameters: Name Type Description Default warp_pipe_name str A partially matching string of a pipe name contained in the graph. This string will be fuzzily matched. required configs Optional[Dict[str, Union[str, List[str], Dict[str, Any]]]] A dict mapping a (fuzzy) pipe name to parameter values that should be used. The parameter values can be passed by config file paths or directly using a proper dict structure. If the dict value is List[str] , then it is assumed that the list entries are paths to config files. If the dict value is Dict[str, Any] , then the parameter whose name matches the dict key will be updated according to the value. If the value is another dict, then this will be merged with the existing dict, giving precedence to the passed values. Note All pipes specified by the key values will be rebuilt regardless of their timestamps. None rebuild_all bool A flag that forces warp to rebuild all pipes in the lineage of warp_pipe_name . False rebuild_static_products bool Flag forcing warp to re-generate static products. Only useful if Workspace was initialized using the link_static_products=True flag. False Examples: The following example will force a rebuild of the exmaple.A and example.C pipes. In the A case, existing parameter values will be overridden by the values found in config/A .yml . In the C case, only the message` parameter is overridden with the specified value. ws . backfill ( 'D' , configs = { 'A' : 'config/A1.yml' , 'C' : dict ( message = 'OVERRIDE_C' ), }, ) build ( self , warp_pipe_name , * , config = None , warp_backfill_call = False ) Build a pipe according to its user-defined pipe class. If any upstream pipes are out-of-sync, an exception will be raised prompting you to use backfill instead. Update pipe parameters from loaded config files. If a keyword argument is specified, this always takes precedence over config file values. Parameters: Name Type Description Default warp_pipe_name str A partially matching string of a pipe name contained in the graph. This string will be fuzzily matched. required config Union[str, List[str], Dict[str, Any]] None warp_backfill_call bool Internal flag indicating whether or not build is being called through self.backfill False clear_cache ( self , session_id = None , clear_all = False ) Delete cached metadata about pipes for currently loaded session -- parameter values, commit hash, timestamps etc. Parameters: Name Type Description Default session_id Optional[str] The name of the session to clear. None clear_all bool If True, deletes full warp cache, including all session directories therein. If False, deletes cache for currently loaded session only. False TODO: allow the clearing of specific pipes within a session. create_session ( self , session_id ) Create a new session with the id session_id and load into it. Parameters: Name Type Description Default session_id str The name of the new session to create. Must not collide with an existing session. required gui ( self ) Launch the GUI mode of WARP. See warp.visualization.gui . load_session ( self , session_id ) Load an existing session. Parameters: Name Type Description Default session_id str The name of the session to load. Note There is no fuzzy matching -- session_id must match an existing session_id exactly. required parameters ( self , pipe_name ) List the parameter values that are currently loaded for a pipe. Parameters: Name Type Description Default pipe_name str Name of the pipe. Note pipe_name is fuzzily matched against existing pipes in the graph. required products ( self , pipe_name ) List the products that a pipe will produce. Parameters: Name Type Description Default pipe_name str Name of the pipe. Note pipe_name is fuzzily matched against existing pipes in the graph. required resume ( self ) Load the most recent session. show ( self , path = None , verbose = False ) Visualize the pipe graph using graphviz. Optionally save the visualization to a file path. See warp.visualization . Parameters: Name Type Description Default path Optional[str] Path to save visualization of the pipeline. None verbose bool If True, display the full node/edge labels. False status ( self , pipe_name ) Report whether a data pipe exists and when it was built. Parameters: Name Type Description Default pipe_name str Name of the target pipe (will be fuzzily matched). required view_pipe ( self , pipe_name , return_str = False , full_file = False ) Display the source code for a pipe. Parameters: Name Type Description Default pipe_name str Name of the pipe in the graph. Note Will be fuzzily matched. required return_str bool Flag to return the source code of the pipe as a string. False full_file bool Flag to show the full contents of the source file rather than just the pipe class declaration therein. False","title":"Workspace"},{"location":"workspace/workspace/#workspace","text":"The Workspace object is the main interface through which the user can interact with their pipeline -- it serves as a manager for the other core classes that WARP provides, namely the Graph . It provides a set of tools for generating desired outputs, inspecting historical outputs, and for visualizing the pipeline itself. Notably, Workspace is the object that enables pipeline reproducibility by keeping track of data provenance, parameter values used at runtime by each pipe, as well as some other metadata. It is also worth noting that Workspace can be integrated easily into other scripts that extend functionality e.g. a script that launches multiple sessions to be run in parallel. Creating a Workspace instance will typically be the last step in initializing your WARP pipeline. It requires an instantiated Graph object passed to __init__ . Once the Workspace instance has been created, the next most common step will be to call build or backfill to generate pipeline output.","title":"Workspace"},{"location":"workspace/workspace/#warp.workspace.workspace.Workspace.configs","text":"Search for declared config files and load them. Results are cached via @functools.lru_cache(maxsize=1) .","title":"configs"},{"location":"workspace/workspace/#warp.workspace.workspace.Workspace.methods","text":"List the available methods for the user.","title":"methods"},{"location":"workspace/workspace/#warp.workspace.workspace.Workspace.pipes","text":"List the pipes present in the pipeline graph.","title":"pipes"},{"location":"workspace/workspace/#warp.workspace.workspace.Workspace.session_timestamps","text":"List the timestamp of each existing session.","title":"session_timestamps"},{"location":"workspace/workspace/#warp.workspace.workspace.Workspace.sessions","text":"List the available sessions.","title":"sessions"},{"location":"workspace/workspace/#warp.workspace.workspace.Workspace.__init__","text":"Parameters: Name Type Description Default graph Optional[str] Constructed pipeline graph. None session_id Optional[str] The unique id for the session to launch. If the id does not already exist, this creates a new session with that id. None link_static_products bool Link static products produced by other sessions to this session and resolve backfill operations accordingly. False","title":"__init__()"},{"location":"workspace/workspace/#warp.workspace.workspace.Workspace.backfill","text":"Call build on all out-of-sync upstream pipes to warp_pipe_name , including warp_pipe_name itself as the terminal build. Note If there are no out-of-sync upstream pipes, backfill reduces to simply calling build on warp_pipe_name . Parameters: Name Type Description Default warp_pipe_name str A partially matching string of a pipe name contained in the graph. This string will be fuzzily matched. required configs Optional[Dict[str, Union[str, List[str], Dict[str, Any]]]] A dict mapping a (fuzzy) pipe name to parameter values that should be used. The parameter values can be passed by config file paths or directly using a proper dict structure. If the dict value is List[str] , then it is assumed that the list entries are paths to config files. If the dict value is Dict[str, Any] , then the parameter whose name matches the dict key will be updated according to the value. If the value is another dict, then this will be merged with the existing dict, giving precedence to the passed values. Note All pipes specified by the key values will be rebuilt regardless of their timestamps. None rebuild_all bool A flag that forces warp to rebuild all pipes in the lineage of warp_pipe_name . False rebuild_static_products bool Flag forcing warp to re-generate static products. Only useful if Workspace was initialized using the link_static_products=True flag. False Examples: The following example will force a rebuild of the exmaple.A and example.C pipes. In the A case, existing parameter values will be overridden by the values found in config/A .yml . In the C case, only the message` parameter is overridden with the specified value. ws . backfill ( 'D' , configs = { 'A' : 'config/A1.yml' , 'C' : dict ( message = 'OVERRIDE_C' ), }, )","title":"backfill()"},{"location":"workspace/workspace/#warp.workspace.workspace.Workspace.build","text":"Build a pipe according to its user-defined pipe class. If any upstream pipes are out-of-sync, an exception will be raised prompting you to use backfill instead. Update pipe parameters from loaded config files. If a keyword argument is specified, this always takes precedence over config file values. Parameters: Name Type Description Default warp_pipe_name str A partially matching string of a pipe name contained in the graph. This string will be fuzzily matched. required config Union[str, List[str], Dict[str, Any]] None warp_backfill_call bool Internal flag indicating whether or not build is being called through self.backfill False","title":"build()"},{"location":"workspace/workspace/#warp.workspace.workspace.Workspace.clear_cache","text":"Delete cached metadata about pipes for currently loaded session -- parameter values, commit hash, timestamps etc. Parameters: Name Type Description Default session_id Optional[str] The name of the session to clear. None clear_all bool If True, deletes full warp cache, including all session directories therein. If False, deletes cache for currently loaded session only. False TODO: allow the clearing of specific pipes within a session.","title":"clear_cache()"},{"location":"workspace/workspace/#warp.workspace.workspace.Workspace.create_session","text":"Create a new session with the id session_id and load into it. Parameters: Name Type Description Default session_id str The name of the new session to create. Must not collide with an existing session. required","title":"create_session()"},{"location":"workspace/workspace/#warp.workspace.workspace.Workspace.gui","text":"Launch the GUI mode of WARP. See warp.visualization.gui .","title":"gui()"},{"location":"workspace/workspace/#warp.workspace.workspace.Workspace.load_session","text":"Load an existing session. Parameters: Name Type Description Default session_id str The name of the session to load. Note There is no fuzzy matching -- session_id must match an existing session_id exactly. required","title":"load_session()"},{"location":"workspace/workspace/#warp.workspace.workspace.Workspace.parameters","text":"List the parameter values that are currently loaded for a pipe. Parameters: Name Type Description Default pipe_name str Name of the pipe. Note pipe_name is fuzzily matched against existing pipes in the graph. required","title":"parameters()"},{"location":"workspace/workspace/#warp.workspace.workspace.Workspace.products","text":"List the products that a pipe will produce. Parameters: Name Type Description Default pipe_name str Name of the pipe. Note pipe_name is fuzzily matched against existing pipes in the graph. required","title":"products()"},{"location":"workspace/workspace/#warp.workspace.workspace.Workspace.resume","text":"Load the most recent session.","title":"resume()"},{"location":"workspace/workspace/#warp.workspace.workspace.Workspace.show","text":"Visualize the pipe graph using graphviz. Optionally save the visualization to a file path. See warp.visualization . Parameters: Name Type Description Default path Optional[str] Path to save visualization of the pipeline. None verbose bool If True, display the full node/edge labels. False","title":"show()"},{"location":"workspace/workspace/#warp.workspace.workspace.Workspace.status","text":"Report whether a data pipe exists and when it was built. Parameters: Name Type Description Default pipe_name str Name of the target pipe (will be fuzzily matched). required","title":"status()"},{"location":"workspace/workspace/#warp.workspace.workspace.Workspace.view_pipe","text":"Display the source code for a pipe. Parameters: Name Type Description Default pipe_name str Name of the pipe in the graph. Note Will be fuzzily matched. required return_str bool Flag to return the source code of the pipe as a string. False full_file bool Flag to show the full contents of the source file rather than just the pipe class declaration therein. False","title":"view_pipe()"}]}